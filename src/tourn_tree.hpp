// приколюха этой побетни в том что она умеет находить не только самый самый пиздатый элемент но ещё и предпиздатый
// используя при этом минимум сравнений, но кого это ебет?
// и да это всё что делает этот алгоритм, исчет два самых самых числа в последовательности

// адекватные челики нашли бы за (O)2n
// но нет же блядь нужно за (O)n + logn
// вот бля на жопе не сиделось то!

#include <list>     // двусвязный список
#include <iostream> // для вывода инфы
#include <climits>  // отсюда INT_MAX взял

using namespace std; // удобно

// узел дерева пиздатости
// да, да всё как в бинарном дере
struct Node
{
    int idx;            // номер пиздатого типка
    Node *left, *right; // падлы под типком ходящие
};

// создает узел дерева пиздатости
Node *create_node(int idx); // начальное значение пиздатости

// Эта хуяня нахуодит не самого пиздатого типа,
// после чего хуярит яго по ссылке в переменную res.
// И да чем меньше тем лудше. (критерий пиздатости пиздатости)
void traverse_height(Node *root, // корень дерева
                     int arr[],  // массовка
                     int &res    // пиздатый типок
);

// Выводит только самых пиздатых типов из массовки
// Путем построения турнирного дерева
void find_second_min(
    int arr[], // массовка ,
    int n      // численность массовки
);
